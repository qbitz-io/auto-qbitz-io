[
  {
    "id": "97909396",
    "file_path": "backend/agents/builder.py",
    "content": "\"\"\"Builder agent - writes and updates Python and JS/TS files.\"\"\"\nfrom typing import Dict, Any\nfrom langchain.agents import AgentExecutor, create_tool_calling_agent\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder\nfrom ..core import get_llm, state_manager, BuildStep\nfrom ..tools import BASE_TOOLS\nimport uuid\n\n\nBUILDER_PROMPT = \"\"\"You are the Builder agent for a self-building LangChain system.\n\nYour responsibility is to write and update code files (Python, JavaScript, TypeScript, JSX).\n\nWhen given a build task:\n1. Understand the requirements and context\n2. Check if related files already exist\n3. Write complete, production-ready code\n4. Follow best practices and patterns\n5. Ensure proper imports and dependencies\n6. Add docstrings and type hints (Python)\n7. Make code async-safe where applicable\n\nCode quality requirements:\n- NO placeholders or TODOs\n- NO incomplete implementations\n- Proper error handling\n- Clear variable names\n- Modular and maintainable\n\nFor Python:\n- Use type hints\n- Follow PEP 8\n- Add docstrings\n- Use async/await for I/O operations\n\nFor JavaScript/TypeScript/JSX:\n- Use TypeScript when possible\n- Follow modern ES6+ syntax\n- Proper component structure for React\n\nYou have tools to:\n- Read existing files\n- Write new files\n- Check if files exist\n- Validate Python syntax\n- List directories\n\nCurrent project structure: {project_root}\nGenerated files: {generated_files}\n\"\"\"\n\n\n# Mapping from language to file extension and target directory\nLANGUAGE_FILE_MAP = {\n    \"python\": {\"ext\": \".py\", \"dir\": \"backend/agents\"},\n    \"javascript\": {\"ext\": \".js\", \"dir\": \"frontend/components\"},\n    \"typescript\": {\"ext\": \".ts\", \"dir\": \"frontend/components\"},\n    \"jsx\": {\"ext\": \".tsx\", \"dir\": \"frontend/components\"},\n    \"tsx\": {\"ext\": \".tsx\", \"dir\": \"frontend/components\"},\n}\n\n\nclass BuilderAgent:\n    \"\"\"Agent that writes and updates code files.\"\"\"\n    \n    def __init__(self):\n        self.llm = get_llm(temperature=0.1)  # Slightly higher for code generation\n        self.tools = BASE_TOOLS\n        self.agent_executor = None\n        self._initialize_agent()\n    \n    def _initialize_agent(self):\n        \"\"\"Initialize the LangChain agent with tools.\"\"\"\n        prompt = ChatPromptTemplate.from_messages([\n            (\"system\", BUILDER_PROMPT),\n            MessagesPlaceholder(variable_name=\"chat_history\", optional=True),\n            (\"human\", \"{input}\"),\n            MessagesPlaceholder(variable_name=\"agent_scratchpad\"),\n        ])\n        \n        agent = create_tool_calling_agent(self.llm, self.tools, prompt)\n        self.agent_executor = AgentExecutor(\n            agent=agent,\n            tools=self.tools,\n            verbose=True,\n            max_iterations=20,\n            handle_parsing_errors=True\n        )\n    \n    def _route_file(self, language: str, filename: str) -> str:\n        \"\"\"Determine the correct file path based on language and filename.\n\n        Args:\n            language: Programming language or file type\n            filename: Base filename without extension\n\n        Returns:\n            Full relative file path with correct extension and directory\n        \"\"\"\n        mapping = LANGUAGE_FILE_MAP.get(language.lower())\n        if mapping:\n            ext = mapping[\"ext\"]\n            directory = mapping[\"dir\"]\n        else:\n            # Default to python if unknown\n            ext = \".py\"\n            directory = \"backend/agents\"\n        \n        return f\"{directory}/{filename}{ext}\"\n\n    async def build(self, task: str, context: Dict[str, Any] = None) -> Dict[str, Any]:\n        \"\"\"Execute a build task.\n        \n        Args:\n            task: Description of what to build\n            context: Additional context (file paths, requirements, language, filename, etc.)\n        \n        Returns:\n            Build result\n        \"\"\"\n        # Get current state\n        state = await state_manager.get_state()\n        \n        # Prepare context\n        from ..core import settings\n        full_context = {\n            \"project_root\": str(settings.project_root),\n            \"generated_files\": state.generated_files,\n        }\n        \n        if context:\n            full_context.update(context)\n        \n        # Determine file path if language and filename provided\n        if context and \"language\" in context and \"filename\" in context:\n            file_path = self._route_file(context[\"language\"], context[\"filename\"])\n            full_context[\"file_path\"] = file_path\n        \n        # Create build step\n        step_id = str(uuid.uuid4())\n        step = BuildStep(\n            id=step_id,\n            agent=\"builder\",\n            action=task,\n            status=\"running\"\n        )\n        await state_manager.add_build_step(step)\n        \n        try:\n            # Run agent\n            result = await self.agent_executor.ainvoke({\n                \"input\": task,\n                **full_context\n            })\n            \n            # Update step\n            await state_manager.update_build_step(\n                step_id,\n                status=\"completed\",\n                result=str(result.get(\"output\", \"\"))\n            )\n            \n            return result\n        \n        except Exception as e:\n            await state_manager.update_build_step(\n                step_id,\n                status=\"failed\",\n                error=str(e)\n            )\n            raise\n\n\n# Global builder instance\nbuilder = BuilderAgent()\n",
    "reason": "Auto attempted to modify protected core file: backend/agents/builder.py",
    "requested_at": "2026-02-10T11:35:07.165478",
    "status": "approved",
    "reviewed_at": "2026-02-10T11:35:13.900958"
  },
  {
    "id": "769ec663",
    "file_path": "backend/tools/base_tools.py",
    "content": "\"\"\"Base tools for the self-building system.\"\"\"\nimport os\nimport ast\nimport subprocess\nfrom pathlib import Path\nfrom typing import Optional, List\nfrom langchain_core.tools import tool\nfrom ..core import settings, state_manager\nfrom ..core.file_guardian import file_guardian\n\n# Windows reserved filenames (case insensitive)\nWINDOWS_RESERVED_NAMES = {\n    \"nul\", \"con\", \"prn\", \"aux\",\n    *(f\"com{i}\" for i in range(1, 10)),\n    *(f\"lpt{i}\" for i in range(1, 10)),\n}\n\n\n@tool\nasync def read_file(file_path: str) -> str:\n    \"\"\"Read the contents of a file.\n    \n    Args:\n        file_path: Path to the file to read (relative to project root)\n    \n    Returns:\n        File contents as string\n    \"\"\"\n    full_path = settings.project_root / file_path\n    try:\n        with open(full_path, 'r') as f:\n            return f.read()\n    except Exception as e:\n        return f\"Error reading file: {str(e)}\"\n\n\n@tool\nasync def write_file(file_path: str, content: str) -> str:\n    \"\"\"Write content to a file, creating directories if needed.\n\n    Protected core files require human approval before they can be modified.\n    Forbidden files (.env, .git) are always blocked.\n\n    Args:\n        file_path: Path to the file to write (relative to project root)\n        content: Content to write to the file\n\n    Returns:\n        Success or error message\n    \"\"\"\n    # Normalize filename for reserved name check\n    filename = Path(file_path).name.lower()\n\n    # Check Windows reserved filenames\n    if filename in WINDOWS_RESERVED_NAMES:\n        return f\"BLOCKED: '{filename}' is a Windows reserved filename and cannot be used.\"\n\n    # GUARDIAN CHECK: Block forbidden files entirely\n    if file_guardian.is_forbidden(file_path):\n        return f\"BLOCKED: '{file_path}' is a forbidden path and cannot be written to.\"\n\n    # GUARDIAN CHECK: Protected files need human approval\n    if file_guardian.is_protected(file_path):\n        approval = await file_guardian.request_approval(\n            file_path=file_path,\n            content=content,\n            reason=f\"Auto attempted to modify protected core file: {file_path}\",\n        )\n        return (\n            f\"QUEUED FOR APPROVAL: '{file_path}' is a protected core file. \"\n            f\"Change has been queued for human review (approval id: {approval.id}). \"\n            f\"A human must approve this change at /api/approvals/{approval.id}/approve before it takes effect. \"\n            f\"Do NOT attempt to bypass this protection.\"\n        )\n\n    # Pre-write syntax validation for Python files\n    if file_path.endswith('.py'):\n        try:\n            ast.parse(content)\n        except SyntaxError as e:\n            return f\"SYNTAX ERROR: {str(e)}\"\n\n    # Non-protected file: write normally\n    full_path = settings.project_root / file_path\n    try:\n        full_path.parent.mkdir(parents=True, exist_ok=True)\n        with open(full_path, 'w') as f:\n            f.write(content)\n\n        # Track generated file\n        await state_manager.add_generated_file(file_path)\n\n        return f\"Successfully wrote to {file_path}\"\n    except Exception as e:\n        return f\"Error writing file: {str(e)}\"\n\n\n@tool\nasync def list_directory(directory_path: str = \".\") -> str:\n    \"\"\"List contents of a directory.\n    \n    Args:\n        directory_path: Path to directory (relative to project root)\n    \n    Returns:\n        List of files and directories\n    \"\"\"\n    full_path = settings.project_root / directory_path\n    try:\n        items = []\n        for item in sorted(full_path.iterdir()):\n            item_type = \"DIR\" if item.is_dir() else \"FILE\"\n            items.append(f\"{item_type}: {item.name}\")\n        return \"\\n\".join(items)\n    except Exception as e:\n        return f\"Error listing directory: {str(e)}\"\n\n\n@tool\nasync def validate_python_syntax(code: str) -> str:\n    \"\"\"Validate Python code syntax.\n    \n    Args:\n        code: Python code to validate\n    \n    Returns:\n        Validation result message\n    \"\"\"\n    try:\n        ast.parse(code)\n        return \"Python syntax is valid\"\n    except SyntaxError as e:\n        return f\"Syntax error: {str(e)}\"\n\n\n@tool\nasync def run_command(command: str, cwd: Optional[str] = None) -> str:\n    \"\"\"Run a shell command and return output.\n    \n    Args:\n        command: Command to run\n        cwd: Working directory (relative to project root)\n    \n    Returns:\n        Command output or error\n    \"\"\"\n    work_dir = settings.project_root / cwd if cwd else settings.project_root\n    try:\n        result = subprocess.run(\n            command,\n            shell=True,\n            cwd=work_dir,\n            capture_output=True,\n            text=True,\n            timeout=30\n        )\n        output = result.stdout if result.returncode == 0 else result.stderr\n        return f\"Exit code: {result.returncode}\\n{output}\"\n    except subprocess.TimeoutExpired:\n        return \"Command timed out after 30 seconds\"\n    except Exception as e:\n        return f\"Error running command: {str(e)}\"\n\n\n@tool\nasync def get_system_state() -> str:\n    \"\"\"Get current system state including capabilities and build history.\n    \n    Returns:\n        JSON representation of system state\n    \"\"\"\n    state = await state_manager.get_state()\n    return state.model_dump_json(indent=2)\n\n\n@tool\nasync def check_file_exists(file_path: str) -> str:\n    \"\"\"Check if a file exists.\n    \n    Args:\n        file_path: Path to check (relative to project root)\n    \n    Returns:\n        \"exists\" or \"not found\"\n    \"\"\"\n    full_path = settings.project_root / file_path\n    return \"exists\" if full_path.exists() else \"not found\"\n\n\n# Export all tools as a list\nBASE_TOOLS = [\n    read_file,\n    write_file,\n    list_directory,\n    validate_python_syntax,\n    run_command,\n    get_system_state,\n    check_file_exists,\n]\n",
    "reason": "Auto attempted to modify protected core file: backend/tools/base_tools.py",
    "requested_at": "2026-02-10T11:35:26.488428",
    "status": "approved",
    "reviewed_at": "2026-02-10T11:35:35.029374"
  }
]